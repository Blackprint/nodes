{"version":3,"sources":["_init.js","Array/Contains.js","Array/Create.js","Array/IndexOf.js","Array/Insert.js","Array/Length.js","Array/Pop.js","Array/Push.js","Array/RemoveAt.js","Array/Shift.js","Array/Unshift.js","Boolean/Invert.js","Map/Create.js","Map/Has.js","Map/Set.js","Number/Add.js","Number/Divide.js","Number/Modulo.js","Number/Multiply.js","Number/PowerOf.js","Number/Subtract.js","Object/Create.js","Object/Deconstructor.js","String/Add.code.js","String/Add.js","String/Char At.js","String/Code Point At.js","String/Ends With.js","String/Includes.js","String/IndexOf.js","String/Last Index Of.js","String/Length.js","String/Match.js","String/Repeat.js","String/Replace.js","String/Search.js","String/Slice.js","String/Split.js","String/Starts With.js","String/Trim.js","Any/To/Trigger.js","Boolean/Compare/And.code.js","Boolean/Compare/And.js","Boolean/Compare/Or.code.js","Boolean/Compare/Or.js","Boolean/Compare/Xor.code.js","Boolean/Compare/Xor.js","Boolean/To/Route.code.js","Boolean/To/Route.js","Boolean/To/Trigger.code.js","Boolean/To/Trigger.js","Map/Get/Keys.js","Map/Get/Size.js","Map/Get/Value.js","Map/Get/Values.js","Number/Binary/And.js","Number/Binary/Or.js","Number/Binary/ShiftLeft.js","Number/Binary/ShiftRight.js","Number/Binary/Xor.js","Number/Compare/Equal.js","Number/Compare/Less Than or Equal.js","Number/Compare/Less Than.js","Number/Compare/More Than or Equal.js","Number/Compare/More Than.js","Number/Compare/Not Equal.js","Number/To/Fixed.js","Number/To/String.js","Object/Get/Keys.js","Object/Get/Value.js","Object/Get/Values.js","Object/Set/Value.js","Route/From/Callback.code.js","Route/From/Callback.js","Route/To/Trigger.code.js","Route/To/Trigger.js","String/Compare/Equal.js","String/Compare/Not Equal.js","String/Padding/End.js","String/Padding/Start.js","String/To/LowerCase.js","String/To/Number.js","String/To/RegExp.js","String/To/UpperCase.js"],"names":["_Class","_Class2","_Class3","_Class4","_Class5","_Class6","_Class7","_Class8","_Class9","_Class0","_Class1","_Class10","_Class11","_Class12","_Class13","_Class14","_Class15","_Class16","_Class17","_Class18","_Class19","_Class20","_Class21","_Class22","_Class23","_Class24","_Class25","_Class26","_Class27","_Class28","_Class29","_Class30","_Class31","_Class32","_Class33","_Class34","_Class35","_Class36","_Class37","_Class38","_Class39","_Class40","_Class41","_Class42","_Class43","_Class44","_Class45","_Class46","_Class47","_Class48","_Class49","_Class50","_Class51","_Class52","_Class53","_Class54","_Class55","_Class56","_Class57","_Class58","_Class59","_Class60","_Class61","_Class62","_Class63","_NumFixed","_NumString","_Class64","_Class65","_Class66","_Class67","_Class68","_Class69","_Class70","_Class71","_Class72","_Class73","_Class74","_Class75","_LowerCase","_Str2Number","_Str2RegExp","_UpperCase","_classPrivateFieldLooseBase","e","t","hasOwnProperty","call","TypeError","id","_classPrivateFieldLooseKey","window","globalThis","async","imports","urls","sf","loader","mjs","Promise","all","map","v","import","task","Blackprint","loadScope","url","hasInterface","hasDocs","Context","createContext","EventSlot","slot","$","Environment","isBrowser","registerInterface","IFace","DataMinimal","Interface","NodeToast","constructor","iface","this","_have","clear","haveInfo","destroy","haveWarn","haveError","_reduceText","text","replace","full","slice","info","$decoration","temp","_raw","warn","error","success","registerNode","Node","instance","super","setInterface","title","_toast","update","Input","Output","ref","val","Array","Exist","includes","Item","input","Types","Any","output","Boolean","init","node","portMenu","callback","createPort","String","data","length","notifyEditorDataChanged","Error","deletePort","name","i","key","on","port","menu","context","push","source","imported","Object","values","Index","indexOf","Number","splice","Length","Value","pop","Data","DeleteCount","Port","Default","shift","unshift","createIcon","document","createTextNode","initUpdate","InitUpdate","NoRouteIn","NoInputCable","Map","Key","has","set","A","B","value","BPEditor","Dialog","list","assign","exportData","Slot","_uninit_","refreshTypes","_refreshTrigger","IInput","In","target","off","keys","IOutput","targetPort","cables","once","struct","feature","StructOf","disconnectAll","_struct","type","assignType","registerCode","Code","js","routes","CodeType","NotWrapped","code","python","routeIn","CodeRoute","MustHave","routeOut","Result","charAt","codePointAt","Haystack","Needle","endsWith","IsExist","lastIndexOf","w","Matches","match","RegExp","Count","repeat","Replacement","Union","search","Begin","End","Splitter","split","startsWith","trim","Call","Trigger","csharp","php","golang","rust","isAsync","JSON","stringify","signal","Optional","Route","Keys","Size","size","get","Values","Precision","Out","toFixed","showPortName","Radix","toString","hasFieldData","hasFieldCable","Field","default","Object_","_getter","message","recreateFunc","props","test","Function","syncIn","GetValue","DataObjectGetValueData","_iface","_props","defineProperty","writable","syncOut","utils","setEnumerablePrototype","None","Filler","padEnd","padStart","toUpperCase","isNaN","Options"],"mappings":"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","file":"nodes-data.mjs","sourcesContent":["// This script will run first, and then the other files\n// depends on blackprint.config.js configuration\n\n// Because .js and .sf is separated\n// we also need to call loadScope just like _init.js\nlet Blackprint = window.Blackprint.loadScope({\n\t// You can find the URL on Blackprint menu -> Modules\n\t// This will also be exported to JSON if this module's nodes is being used\n\turl: import.meta.url,\n\n\t// This will autoload (*.sf.mjs) and (*.sf.css) file for Browser\n\thasInterface: true,\n\n\t// This will autoload (*.docs.json) for Browser\n\thasDocs: true,\n});\n\n// Global shared context\nlet Context = Blackprint.createContext('Data');\n\n// This is needed to avoid duplicated event listener when using hot reload\n// Event listener that registered with same slot will be replaced\nContext.EventSlot = {slot: 'my-private-event-slot'};\n\nlet $ = globalThis.sf?.$;\nif(!Blackprint.Environment.isBrowser)\n\t$ = ()=> [];\n\n\n// Register with default interface\nBlackprint.registerInterface(\"BPIC/Data/Minimal\",\nContext.IFace.DataMinimal = class extends Blackprint.Interface { });\n\n// Bootstrap for add toast on node decoration\nlet NodeToast = Context.NodeToast = class NodeToast {\n\tconstructor(iface){\n\t\tthis.iface = iface;\n\t\tthis._have = false;\n\t}\n\n\tclear(){\n\t\t// Early return to improve performance\n\t\tif(this._have === false) return;\n\n\t\tif(this.haveInfo)\n\t\t\tthis.haveInfo.destroy();\n\t\tif(this.haveWarn)\n\t\t\tthis.haveWarn.destroy();\n\t\tif(this.haveError)\n\t\t\tthis.haveError.destroy();\n\n\t\tthis.haveInfo = false;\n\t\tthis.haveWarn = false;\n\t\tthis.haveError = false;\n\t}\n\n\t_reduceText(text){\n\t\tthis._have = true;\n\t\treturn text.replace(/\\w{15,}/g, full => full.slice(0, 5)+'...');\n\t}\n\n\tinfo(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveInfo)\n\t\t\tthis.haveInfo.text = text;\n\t\telse\n\t\t\tthis.haveInfo = this.iface.$decoration.info(text);\n\n\t\tthis.haveInfo._raw = temp;\n\t}\n\n\twarn(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveWarn)\n\t\t\tthis.haveWarn.text = text;\n\t\telse\n\t\t\tthis.haveWarn = this.iface.$decoration.warn(text);\n\n\t\tthis.haveWarn._raw = temp;\n\t}\n\n\terror(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveError)\n\t\t\tthis.haveError.text = text;\n\t\telse\n\t\t\tthis.haveError = this.iface.$decoration.error(text);\n\n\t\tthis.haveError._raw = temp;\n\t}\n\n\tsuccess(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet ref = this.iface.$decoration.success(this._reduceText(text));\n\t\tref._raw = text;\n\t}\n}","/**\n * Check if item exist in an array\n * @summary Check if item exist in an array\n * @blackprint node\n */\nBlackprint.registerNode('Data/Array/Contains',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tArray: Array,\n\t\tItem: Blackprint.Types.Any,\n\t};\n\n\tstatic output = {\n\t\tExist: Boolean,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"IndexOf\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\t\tlet val = Input.Array;\n\n\t\tif(val == null)\n\t\t\treturn this._toast.warn(\"Array must not be null\");\n\n\t\tOutput.Exist = val.includes(Input.Item);\n\t}\n});","/**\n * Create a new array\n * Any input update will recreate the array\n * Reusing the outputted array is more recommended than recreate the array\n * @summary Create a new Array\n * @blackprint node\n */\nBlackprint.registerNode('Data/Array/Create',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\t/**\n\t\t * You can right click this port to create a new port\n\t\t * Delete every input port if you want to create empty object\n\t\t */\n\t\t'0': Blackprint.Types.Any,\n\t};\n\tstatic output = {\n\t\t/** Array will be recreated everytime input was changed */\n\t\tArray: Array,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Create Array\";\n\t}\n\n\tinit(){\n\t\tlet node = this;\n\t\tlet iface = this.iface;\n\n\t\t// Put this array here, and reuse when port menu event\n\t\tvar portMenu = [{\n\t\t\ttitle:\"Create input port\", callback(){\n\t\t\t\t// Always create on last position -> (key, default value)\n\t\t\t\tnode.createPort('input', String(iface.data.length), Blackprint.Types.Any);\n\t\t\t\tiface.data.length++;\n\t\t\t\tnode.update();\n\n\t\t\t\t// Let editor know if this iface changed and unsaved\n\t\t\t\tnode.notifyEditorDataChanged();\n\t\t\t}\n\t\t}, {\n\t\t\ttitle:\"Delete port\", callback(){\n\t\t\t\tif(iface.data.length === 0) throw new Error(\"There's no input port\");\n\n\t\t\t\tnode.deletePort('input', this.name);\n\t\t\t\tiface.data.length--;\n\n\t\t\t\tlet i = 0;\n\t\t\t\tlet input = iface.input;\n\t\t\t\tfor (let key in input) {\n\t\t\t\t\tinput[key].name = String(i++);\n\t\t\t\t}\n\n\t\t\t\tnode.update();\n\n\t\t\t\t// Let editor know if this iface changed and unsaved\n\t\t\t\tnode.notifyEditorDataChanged();\n\t\t\t}\n\t\t}];\n\n\t\tiface.on('port.menu', Context.EventSlot, function({ port, menu }){\n\t\t\t// Change callback context to refer current port\n\t\t\tportMenu[0].context = port;\n\t\t\tmenu.push(portMenu[0]);\n\n\t\t\t// Show delete port only when user right clicked input port\n\t\t\tif(port.source === 'output') return;\n\n\t\t\t// Change callback context to refer current port\n\t\t\tportMenu[1].context = port;\n\t\t\tmenu.push(portMenu[1]);\n\t\t});\n\n\t\tthis.update();\n\t}\n\n\timported(data){\n\t\tlet iface = this.iface;\n\t\tif(data == null){\n\t\t\tiface.data = {length: 1};\n\t\t\treturn;\n\t\t}\n\n\t\tthis.deletePort('input', '0');\n\t\tiface.data = data;\n\n\t\tfor (let i=0; i < data.length; i++) {\n\t\t\tthis.createPort('input', i, Blackprint.Types.Any);\n\t\t}\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\n\t\tif(this.iface.data.length === 0){\n\t\t\tOutput.Array = [];\n\t\t\treturn;\n\t\t}\n\n\t\t// Copy every port data into new array\n\t\tOutput.Array = Object.values(Input);\n\t}\n});","/**\n * Find item index from an array\n * @summary Find item index from an array\n * @blackprint node\n */\nBlackprint.registerNode('Data/Array/IndexOf',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tArray: Array,\n\t\tItem: Blackprint.Types.Any,\n\t};\n\t\n\tstatic output = {\n\t\tIndex: Number,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"IndexOf\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\t\tlet val = Input.Array;\n\n\t\tif(val == null)\n\t\t\treturn this._toast.warn(\"Array must not be null\");\n\n\t\tOutput.Index = val.indexOf(Input.Item);\n\t}\n});","/**\n * Insert item on array at index\n * @summary Insert item on array at index\n * @blackprint node\n */\nBlackprint.registerNode('Data/Array/Insert',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tArray: Array,\n\t\tIndex: Number,\n\t\tItem: Blackprint.Types.Any,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Insert\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\t\tlet val = Input.Array;\n\n\t\tif(val == null || Input.Index == null)\n\t\t\treturn this._toast.warn(\"Array or Index must not be null\");\n\n\t\tif(Input.Item == null)\n\t\t\treturn this._toast.warn(\"Item must not be null\");\n\n\t\tval.splice(Input.Index, 0, Input.Item);\n\t}\n});","/**\n * Get array length\n * @summary Get array length\n * @blackprint node\n */\nBlackprint.registerNode('Data/Array/Length',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tArray: Array,\n\t};\n\n\tstatic output = {\n\t\tLength: Number,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Get Length\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\t\tlet val = Input.Array;\n\n\t\tif(val == null)\n\t\t\treturn this._toast.warn(\"Array must not be null\");\n\n\t\tOutput.Length = Input.Array.Length;\n\t}\n});","/**\n * Get the last value of an array and remove it from the array\n * Make sure to use route cable when using this to avoid logic error\n * @summary Get last value and remove it\n * @blackprint node\n */\nBlackprint.registerNode('Data/Array/Pop',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tArray: Array,\n\t};\n\n\tstatic output = {\n\t\tValue: Blackprint.Types.Any,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Pop an Array\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\t\tlet val = Input.Array;\n\n\t\tif(val == null || val.length === 0)\n\t\t\treturn this._toast.warn(\"Empty array\");\n\n\t\tOutput.Value = val.pop();\n\t}\n});","/**\n * Add data to an array, the data will be placed on last index\n * Make sure to use route cable when using this to avoid logic error\n * @summary Add data at last index\n * @blackprint node\n */\nBlackprint.registerNode('Data/Array/Push',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tArray: Array,\n\t\tData: Blackprint.Types.Any,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Push to Array\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input } = this.ref;\n\t\tlet val = Input.Array;\n\n\t\tif(val == null)\n\t\t\treturn this._toast.warn(\"Array must not be null\");\n\n\t\tval.push(Input.Data);\n\t}\n});","/**\n * Remove items start from an index from an array\n * @summary Remove items from an array\n * @blackprint node\n */\nBlackprint.registerNode('Data/Array/RemoveAt',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tArray: Array,\n\t\tIndex: Number,\n\t\tDeleteCount: Blackprint.Port.Default(Number, 1),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"RemoveAt\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input } = this.ref;\n\n\t\tif(Input.Array == null || Input.Index == null || Input.DeleteCount == null)\n\t\t\treturn this._toast.warn(\"Array, Index, or DeleteCount must not be null\");\n\n\t\tInput.Array.splice(Input.Index, Input.DeleteCount);\n\t}\n});","/**\n * Get the first value of an array and remove it from the array\n * Make sure to use route cable when using this to avoid logic error\n * @summary Get first value and remove it\n * @blackprint node\n */\nBlackprint.registerNode('Data/Array/Shift',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tArray: Array,\n\t};\n\n\tstatic output = {\n\t\tValue: Blackprint.Types.Any,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Shift an Array\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\t\tlet val = Input.Array;\n\n\t\tif(val == null || val.length === 0)\n\t\t\treturn this._toast.warn(\"Empty array\");\n\n\t\tOutput.Value = val.shift();\n\t}\n});","/**\n * Add data to an array, the data will be inserted from first index\n * Make sure to use route cable when using this to avoid logic error\n * @summary Insert data from first index\n * @blackprint node\n */\nBlackprint.registerNode('Data/Array/Unshift',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tArray: Array,\n\t\tData: Blackprint.Types.Any,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Unshift to Array\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input } = this.ref;\n\t\tlet val = Input.Array;\n\n\t\tif(val == null)\n\t\t\treturn this._toast.warn(\"Array must not be null\");\n\n\t\tval.unshift(Input.Data);\n\t}\n});","/**\n * Invert `true` to `false` and vice-versa\n * This just like `let NewValue = !Value;`\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Boolean/Invert\",\nclass extends Blackprint.Node {\n\tstatic input = { Value: Boolean };\n\tstatic output = { Value: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Invert Boolean\";\n\t}\n\n\tcreateIcon(){\n\t\treturn document.createTextNode('Invert');\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tref.Output.Value = !ref.Input.Value;\n\t}\n});","/**\n * Create a new Map\n * @summary Create a new Map\n * @blackprint node\n */\nBlackprint.registerNode('Data/Map/Create',\nclass extends Blackprint.Node {\n\tstatic output = {\n\t\tMap: Map,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Create Map\";\n\t}\n\n\tinit(){\n\t\tlet { Output } = this.ref;\n\t\tOutput.Map = new Map();\n\t}\n});","/**\n * Check if Map has an key\n * @summary Check if Map has an key\n * @blackprint node\n */\nBlackprint.registerNode('Data/Map/Has',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tMap: Map,\n\t\tKey: Blackprint.Types.Any,\n\t};\n\tstatic output = {\n\t\tExist: Boolean,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Map has key\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\n\t\tif(Input.Map == null || Input.Key == null)\n\t\t\treturn this._toast.warn(\"Map or Key must not be null\");\n\n\t\tOutput.Exist = Input.Map.has(Input.Key);\n\t}\n});","/**\n * Set data on Map\n * @summary Set data on Map\n * @blackprint node\n */\nBlackprint.registerNode('Data/Map/Set',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tMap: Map,\n\t\tKey: Blackprint.Types.Any,\n\t\tValue: Blackprint.Types.Any,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Set Data\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input } = this.ref;\n\n\t\tif(Input.Map == null || Input.Key == null || Input.Value == null)\n\t\t\treturn this._toast.warn(\"Map, Key, or Value must not be null\");\n\n\t\tInput.Map.set(Input.Key, Input.Value);\n\t}\n});","/**\n * Return added number (A + B)\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Add\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Number: Add\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-plus\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A + B;\n\t}\n});","/**\n * Return divided number (A / B)\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Divide\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Number: Divide\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-divide\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A / B;\n\t}\n});","/**\n * Return the remaining of divided number with modulo (A % B)\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Modulo\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Number: Modulo\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-percentage\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A % B;\n\t}\n});","/**\n * Return multiplied number (A * B)\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Multiply\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Number: Multiply\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-asterisk\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A * B;\n\t}\n});","/**\n * Returns the value of A to the power of B.\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/PowerOf\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Number: PowerOf\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-superscript\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A ** B;\n\t}\n});","/**\n * Return substracted number (A - B)\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Subtract\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Number: Subtract\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-minus\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A - B;\n\t}\n});","/**\n * Create a new object\n * Any input update will recreate the object\n * Reusing the outputted object is more recommended than recreate the object\n * @summary Create a new object\n * @blackprint node\n */\nBlackprint.registerNode('Data/Object/Create',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\t/**\n\t\t * You can right click this port to create or rename new port\n\t\t * Delete every input port if you want to create empty object\n\t\t */\n\t\tkey: Blackprint.Types.Any,\n\t};\n\tstatic output = {\n\t\t/** Object will be recreated everytime input was changed */\n\t\tObject: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Create Object\";\n\t}\n\n\tinit(){\n\t\tlet node = this;\n\t\tlet iface = this.iface;\n\n\t\t// Put this array here, and reuse when port menu event\n\t\tvar portMenu = [{\n\t\t\ttitle: \"Create input port\", async callback(){\n\t\t\t\tlet { value } = await BPEditor.Dialog({\n\t\t\t\t\ttitle: 'Enter field name',\n\t\t\t\t\tinput: 'text',\n\t\t\t\t});\n\n\t\t\t\tif(!value) return;\n\n\t\t\t\t// Always create on last position -> (key, default value)\n\t\t\t\tnode.createPort('input', value, Blackprint.Types.Any);\n\t\t\t\tiface.data.list.push(value);\n\n\t\t\t\tnode.update();\n\n\t\t\t\t// Let editor know if this iface changed and unsaved\n\t\t\t\tnode.notifyEditorDataChanged();\n\t\t\t}\n\t\t}, {\n\t\t\ttitle: \"Delete port\", callback(){\n\t\t\t\tnode.deletePort('input', this.name);\n\n\t\t\t\tlet list = iface.data.list;\n\t\t\t\tlet i = list.indexOf(this.name);\n\n\t\t\t\tif(i !== -1){\n\t\t\t\t\tlist.splice(i, 1);\n\t\t\t\t\tnode.update();\n\t\t\t\t}\n\n\t\t\t\t// Let editor know if this iface changed and unsaved\n\t\t\t\tnode.notifyEditorDataChanged();\n\t\t\t}\n\t\t}];\n\n\t\tiface.on('port.menu', Context.EventSlot, function({ port, menu }){\n\t\t\tfor (var i = 0; i < portMenu.length; i++) {\n\t\t\t\t// Change every callback context to refer current port\n\t\t\t\tportMenu[i].context = port;\n\t\t\t}\n\n\t\t\tmenu.push(...portMenu);\n\t\t});\n\n\t\tthis.update();\n\t}\n\n\timported(data){\n\t\tlet iface = this.iface;\n\t\tif(data == null){\n\t\t\tiface.data = {list: ['key']};\n\t\t\treturn;\n\t\t}\n\n\t\tthis.deletePort('input', 'key');\n\t\tiface.data = data;\n\n\t\tlet list = data.list;\n\t\tfor (let i=0; i < list.length; i++) {\n\t\t\tthis.createPort('input', list[i], Blackprint.Types.Any);\n\t\t}\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\n\t\tif(this.iface.data.length === 0){\n\t\t\tOutput.Object = {};\n\t\t\treturn;\n\t\t}\n\n\t\t// Copy every port data into new object\n\t\tOutput.Object = Object.assign({}, Input);\n\t}\n});","/**\n * Deconstruct an output port's structure\n * This also known as object destructuring in JavaScript\n * Or extract property for an object that have structured\n * @summary Deconstruct a port structure\n * @blackprint node\n */\nBlackprint.registerNode('Data/Object/Deconstructor',\nclass extends Blackprint.Node {\n\tstatic input = { In: Object };\n\tstatic output = {};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Decontructor\";\n\t\tthis._toast = new NodeToast(iface);\n\n\t\t// iface._dynamicPort = true; // Flag this node for having dynamic port\n\t\tiface.exportData = this.exportData;\n\t}\n\n\timported(data){\n\t\tif(data?.output == null) return;\n\n\t\tlet list = data.output;\n\t\tfor (let i=0; i < list.length; i++){\n\t\t\tlet port = this.createPort('output', list[i], Blackprint.Types.Slot);\n\t\t\tport._uninit_ = true;\n\t\t}\n\t}\n\n\tinit(){\n\t\tthis.refreshTypes();\n\t\tthis._refreshTrigger = () => this.refreshTypes();\n\n\t\tthis.ref.IInput.In.on('connecting', this._refreshTrigger);\n\t\tthis.ref.IInput.In.on('disconnect', ({ target }) => {\n\t\t\tif(target != null) target.off('type.assigned', this._refreshTrigger);\n\t\t});\n\t}\n\n\texportData(){\n\t\treturn {\n\t\t\toutput: Object.keys(this.ref.IOutput),\n\t\t};\n\t}\n\n\trefreshTypes(){\n\t\tlet { IInput, IOutput } = this.ref;\n\t\tlet targetPort = IInput.In.cables[0]?.output;\n\n\t\tif(targetPort == null) return;\n\n\t\t// Wait for type assignment if we're deconstructing port from other Deconstructor node\n\t\tif(targetPort._uninit_){\n\t\t\ttargetPort.once('type.assigned', this._refreshTrigger);\n\t\t\treturn;\n\t\t}\n\n\t\tlet { struct, feature } = targetPort;\n\t\tif(feature !== Blackprint.Port.StructOf){\n\t\t\tIInput.In.disconnectAll();\n\t\t\tthrow new Error(\"Deconstructor can only be used for output port type with 'Port.StructOf' feature\");\n\t\t}\n\n\t\tif(this._struct != null){\n\t\t\tif(this._struct !== struct){\n\t\t\t\tIInput.In.disconnectAll();\n\t\t\t\tthrow new Error(\"The new connected port structure is different with old structure object\");\n\t\t\t}\n\n\t\t\t// Skip because the output port types already assigned\n\t\t\telse return;\n\t\t}\n\n\t\tthis._struct = struct;\n\n\t\tfor (let key in IOutput) {\n\t\t\tlet type = struct[key]?.type;\n\n\t\t\t// Delete port that was missing from the defined output port's structure\n\t\t\tif(type == null) this.deletePort('output', key);\n\n\t\t\t// Assign type if exist\n\t\t\telse {\n\t\t\t\tlet port = IOutput[key];\n\t\t\t\tport.assignType(type);\n\t\t\t\tport._uninit_ = false;\n\t\t\t}\n\t\t}\n\n\t\t// Add missing port\n\t\tfor (let key in struct) {\n\t\t\tif(IOutput[key] == null) this.createPort('output', key, struct[key].type);\n\t\t}\n\t}\n});","Blackprint.registerCode('Data/String/Add',\nclass extends Blackprint.Code {\n\tstatic routeIn = Blackprint.CodeRoute.MustHave;\n\tstatic routeOut = Blackprint.CodeRoute.MustHave;\n\n\t// routes == { traceRoute, routeIn, routeOut }\n\tjs(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tcode: `Output.Result = Input.A + Input.B;`,\n\t\t};\n\t}\n\tpython(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tcode: `Output['Result'] = Input['A'] + Input['B']`,\n\t\t};\n\t}\n});","/**\n * Add string to string\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/Add\",\nclass extends Blackprint.Node {\n\tstatic input = { A: String, B: String };\n\tstatic output = { Result: String };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"String: Add\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-plus\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Result = A + B;\n\t}\n});","/**\n * Get char from a string at index\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/CharAt\",\nclass extends Blackprint.Node {\n\tstatic input = { String: String, Index: Number };\n\tstatic output = { Result: String };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Char At\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {String, Index} = ref.Input;\n\n\t\tif(String == null || Index == null) return;\n\t\tref.Output.Result = String.charAt(Index);\n\t}\n});","/**\n * Get char point from a string at index\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/CodePointAt\",\nclass extends Blackprint.Node {\n\tstatic input = { String: String, Index: Number };\n\tstatic output = { Result: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Code Point At\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {String, Index} = ref.Input;\n\n\t\tif(String == null || Index == null) return;\n\t\tref.Output.Result = String.codePointAt(Index);\n\t}\n});","/**\n * Return true if the string have a specified\n * string at the ends of the string\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/EndsWith\",\nclass extends Blackprint.Node {\n\tstatic input = { Haystack: String, Needle: String };\n\tstatic output = { Result: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Ends With\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {Haystack, Needle} = ref.Input;\n\n\t\tif(Haystack == null || Needle == null) return;\n\t\tref.Output.Result = Haystack.endsWith(Needle);\n\t}\n});","/**\n * Return true if a string contains the specified string\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/Includes\",\nclass extends Blackprint.Node {\n\tstatic input = { Haystack: String, Needle: String };\n\tstatic output = { IsExist: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Includes\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {Haystack, Needle} = ref.Input;\n\n\t\tif(Haystack == null || Needle == null) return;\n\t\tref.Output.IsExist = Haystack.includes(Needle);\n\t}\n});","/**\n * Return index of specified string on a string\n * This will return -1 if not exist\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/IndexOf\",\nclass extends Blackprint.Node {\n\tstatic input = { Haystack: String, Needle: String };\n\tstatic output = { Index: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Index Of\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {Haystack, Needle} = ref.Input;\n\n\t\tif(Haystack == null || Needle == null) return;\n\t\tref.Output.Index = Haystack.indexOf(Needle);\n\t}\n});","/**\n * Return the last index of specified string on a string\n * This will return -1 if not exist\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/LastIndexOf\",\nclass extends Blackprint.Node {\n\tstatic input = { Haystack: String, Needle: String };\n\tstatic output = { Index: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Last Index Of\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {Haystack, Needle} = ref.Input;\n\n\t\tif(Haystack == null || Needle == null) return;\n\t\tref.Output.Index = Haystack.lastIndexOf(Needle);\n\t}\n});","/**\n * Return length of a string\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/Length\",\nclass extends Blackprint.Node {\n\tstatic input = { String: String };\n\tstatic output = { Length: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"String: Length\";\n\t\tiface.w = 95;\n\t}\n\n\tcreateIcon(){\n\t\treturn document.createTextNode('Length');\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet { String } = ref.Input;\n\n\t\tif(String == null) return;\n\t\tref.Output.Length = String.length;\n\t}\n});","/**\n * Find match with RegExp\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/Match\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tHaystack: String,\n\t\tNeedle: RegExp\n\t};\n\n\tstatic output = { Matches: Array };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Match\";\n\t}\n\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {Haystack, Needle} = ref.Input;\n\n\t\tif(Haystack == null || Needle == null) return;\n\t\tref.Output.Matches = Haystack.match(Needle);\n\t}\n});","/**\n * Repeat the string few times\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/Repeat\",\nclass extends Blackprint.Node {\n\tstatic input = { String: String, Count: Number };\n\tstatic output = { Result: String };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Repeat\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {String, Count} = ref.Input;\n\n\t\tif(String == null || Count == null) return;\n\t\tref.Output.Result = String.repeat(Count);\n\t}\n});","/**\n * Find a string (needle) from a string (haystack)\n * with a string (replacement)\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/Replace\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tHaystack: String,\n\t\tNeedle: Blackprint.Port.Union([RegExp, String]),\n\t\tReplacement: String,\n\t};\n\n\tstatic output = { Result: String };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Replace\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {Haystack, Needle, Replacement} = ref.Input;\n\n\t\tif(Haystack == null || Needle == null || Replacement == null) return;\n\t\tref.Output.Result = Haystack.replace(Needle, Replacement);\n\t}\n});","/**\n * Find index from a string with RegExp\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/Search\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tHaystack: String,\n\t\tNeedle: Blackprint.Port.Union([String, RegExp])\n\t};\n\n\tstatic output = { Index: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Search\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {Haystack, Needle} = ref.Input;\n\n\t\tif(Haystack == null || Needle == null) return;\n\t\tref.Output.Index = Haystack.search(Needle);\n\t}\n});","/**\n * Slice a string\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/Slice\",\nclass extends Blackprint.Node {\n\tstatic input = { String: String, Begin: Number, End: Number };\n\tstatic output = { Result: String };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Slice\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {String, Begin, End} = ref.Input;\n\n\t\tif(String == null || Begin == null) return;\n\t\tref.Output.Result = String.slice(Begin, End);\n\t}\n});","/**\n * Split a string and return an array\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/Split\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tString: String,\n\t\tSplitter: Blackprint.Port.Union([RegExp, String]),\n\t};\n\tstatic output = { Result: String };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Split\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {String, Splitter} = ref.Input;\n\n\t\tif(String == null || Splitter == null) return;\n\t\tref.Output.Result = String.split(Splitter);\n\t}\n});","/**\n * Return true if the string have a specified\n * string at the beginning of the string\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/StartsWith\",\nclass extends Blackprint.Node {\n\tstatic input = { Haystack: String, Needle: String };\n\tstatic output = { Result: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Starts With\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {Haystack, Needle} = ref.Input;\n\n\t\tif(Haystack == null || Needle == null) return;\n\t\tref.Output.Result = Haystack.startsWith(Needle);\n\t}\n});","/**\n * Trim white space from a string at the start and end of string\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/Trim\",\nclass extends Blackprint.Node {\n\tstatic input = { String: String };\n\tstatic output = { Result: String };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Trim\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {String} = ref.Input;\n\n\t\tif(String == null) return;\n\t\tref.Output.Result = String.trim();\n\t}\n});","/**\n * Trigger a function call on any data changes\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Any/To/Trigger\",\nclass extends Blackprint.Node {\n\tstatic input = { Value: Blackprint.Types.Any };\n\tstatic output = { Call: Blackprint.Types.Trigger };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Trigger on any data changes\";\n\t}\n\n\tcreateIcon(){\n\t\treturn document.createTextNode('Call()');\n\t}\n\n\tupdate(){\n\t\tthis.ref.Output.Call();\n\t}\n});","Blackprint.registerCode('Data/Boolean/Compare/And',\nclass extends Blackprint.Code {\n\tstatic routeIn = Blackprint.CodeRoute.MustHave;\n\tstatic routeOut = Blackprint.CodeRoute.MustHave;\n\tstatic isAsync = true;\n\n\t// routes == { traceRoute, routeIn, routeOut }\n\tjs(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tcode: `Output.Value = Input[\"0\"] && Input[\"1\"];`,\n\t\t};\n\t}\n\n\tcsharp(routes){ return this.php(routes); }\n\tphp(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tcode: `Output[\"Value\"] = Input[\"0\"] && Input[\"1\"];`,\n\t\t};\n\t}\n\n\tpython(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tcode: `Output[\"Value\"] = Input[\"0\"] and Input[\"1\"]`,\n\t\t};\n\t}\n\n\tgolang(routes){\n\t\treturn {\n\t\t\tcode: `Output.Set(\"Value\", Input.Get(\"0\").(bool) && Input.Get(\"1\").(bool))`,\n\t\t};\n\t}\n\n\trust(routes){\n\t\treturn {\n\t\t\tcode: `output.set(\"Value\", input.get::<bool>(\"0\").unwrap() && input.get::<bool>(\"1\").unwrap());`,\n\t\t};\n\t}\n});","/**\n * Compare boolean with AND\n * This will only return `true` if both input is `true`\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Boolean/Compare/And\",\nclass extends Blackprint.Node {\n\tstatic input = { \"0\": Boolean, \"1\": Boolean };\n\tstatic output = { Value: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Boolean: And\";\n\t}\n\n\tcreateIcon(){\n\t\treturn document.createTextNode('And');\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tref.Output.Value = ref.Input[\"0\"] && ref.Input[\"1\"];\n\t}\n});","Blackprint.registerCode('Data/Boolean/Compare/Or',\nclass extends Blackprint.Code {\n\tstatic routeIn = Blackprint.CodeRoute.MustHave;\n\tstatic routeOut = Blackprint.CodeRoute.MustHave;\n\n\t// routes == { traceRoute, routeIn, routeOut }\n\tjs(routes){\n\t\treturn {\n\t\t\tcode: `Output.Value = Input[\"0\"] || Input[\"1\"];`,\n\t\t};\n\t}\n});","/**\n * Compare boolean with OR\n * This will only return `true` if one of the input is `true`\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Boolean/Compare/Or\",\nclass extends Blackprint.Node {\n\tstatic input = { \"0\": Boolean, \"1\": Boolean };\n\tstatic output = { Value: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Boolean: Or\";\n\t}\n\n\tcreateIcon(){\n\t\treturn document.createTextNode('Or');\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tref.Output.Value = ref.Input[\"0\"] || ref.Input[\"1\"];\n\t}\n});","Blackprint.registerCode('Data/Boolean/Compare/Xor',\nclass extends Blackprint.Code {\n\tstatic routeIn = Blackprint.CodeRoute.MustHave;\n\tstatic routeOut = Blackprint.CodeRoute.MustHave;\n\n\t// routes == { traceRoute, routeIn, routeOut }\n\tjs(routes){\n\t\treturn {\n\t\t\tcode: `Output.Value = Input[\"0\"] !== Input[\"1\"];`,\n\t\t};\n\t}\n});","/**\n * Compare boolean with XOR\n * This will only return `true` if the input is not similar\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Boolean/Compare/Xor\",\nclass extends Blackprint.Node {\n\tstatic input = { \"0\": Boolean, \"1\": Boolean };\n\tstatic output = { Value: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Boolean: Xor\";\n\t}\n\n\tcreateIcon(){\n\t\treturn document.createTextNode('Xor');\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tref.Output.Value = ref.Input[\"0\"] !== ref.Input[\"1\"];\n\t}\n});","Blackprint.registerCode('Data/Boolean/To/Route',\nclass extends Blackprint.Code {\n\tstatic routeIn = Blackprint.CodeRoute.MustHave;\n\tstatic routeOut = Blackprint.CodeRoute.Optional;\n\n\t// routes == { traceRoute, routeIn, routeOut }\n\tjs(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tcode: `if(Input.Value === ${JSON.stringify(this.iface.data.signal)}) await Output.Route();`,\n\t\t};\n\t}\n\tpython(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tcode: `if(Input['Value'] == ${\n\t\t\t\tJSON.stringify(this.iface.data.signal) ? 'True' : 'False'\n\t\t\t}): Output['Route']()`,\n\t\t};\n\t}\n});","/**\n * Route to other node if the input receive `true` value\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Boolean/To/Route\",\nclass extends Blackprint.Node {\n\tstatic input = { Value: Boolean };\n\tstatic output = { Route: Blackprint.Types.Route };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Route on true\";\n\t\tiface.data = {signal: true};\n\t}\n\n\tcreateIcon(){\n\t\treturn document.createTextNode('Route ');\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tif(this.ref.Input.Value === this.iface.data.signal)\n\t\t\tthis.ref.Output.Route();\n\t}\n});","Blackprint.registerCode('Data/Boolean/To/Trigger',\nclass extends Blackprint.Code {\n\tstatic routeIn = Blackprint.CodeRoute.MustHave;\n\tstatic routeOut = Blackprint.CodeRoute.Optional;\n\n\t// routes == { traceRoute, routeIn, routeOut }\n\tjs(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tcode: `if(Input.Value === ${JSON.stringify(this.iface.data.signal)}) await Output.Call();`,\n\t\t};\n\t}\n\tpython(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tcode: `if(Input[\"Value\"] == ${this.iface.data.signal ? 'True' : 'False'}): Output[\"Call\"]()`,\n\t\t};\n\t}\n});","/**\n * Trigger a function call if the input receive `true` value\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Boolean/To/Trigger\",\nclass extends Blackprint.Node {\n\tstatic input = { Value: Boolean };\n\tstatic output = { Call: Blackprint.Types.Trigger };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Trigger on true\";\n\t\tiface.data = {signal: true};\n\t}\n\n\tcreateIcon(){\n\t\treturn document.createTextNode('Call()');\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tif(this.ref.Input.Value === this.iface.data.signal)\n\t\t\tthis.ref.Output.Call();\n\t}\n});","/**\n * Get Map's keys\n * @summary Get Map's keys\n * @blackprint node\n */\nBlackprint.registerNode('Data/Map/Get/Keys',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tMap: Map,\n\t};\n\tstatic output = {\n\t\tKeys: Array,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Get Keys\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\n\t\tif(Input.Map == null)\n\t\t\treturn this._toast.warn(\"Map must not be null\");\n\n\t\tOutput.Keys = [...Input.Map.keys()];\n\t}\n});","/**\n * Get Map size\n * @summary Get Map size\n * @blackprint node\n */\nBlackprint.registerNode('Data/Map/Get/Size',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tMap: Map,\n\t};\n\tstatic output = {\n\t\tSize: Number,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Get Size\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\n\t\tif(Input.Map == null)\n\t\t\treturn this._toast.warn(\"Map must not be null\");\n\n\t\tOutput.Size = Input.Map.size;\n\t}\n});","/**\n * Get value from Map\n * @summary Get value from Map\n * @blackprint node\n */\nBlackprint.registerNode('Data/Map/Get/Value',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tMap: Map,\n\t\tKey: Blackprint.Types.Any,\n\t};\n\tstatic output = {\n\t\tValue: Blackprint.Types.Any,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Get Value\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\n\t\tif(Input.Map == null)\n\t\t\treturn this._toast.warn(\"Map must not be null\");\n\n\t\tOutput.Value = Input.Map.get(Input.Key);\n\t}\n});","/**\n * Get Map's values\n * @summary Get Map's values\n * @blackprint node\n */\nBlackprint.registerNode('Data/Map/Get/Values',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tMap: Map,\n\t};\n\tstatic output = {\n\t\tValues: Array,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Get Values\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\n\t\tif(Input.Map == null)\n\t\t\treturn this._toast.warn(\"Map must not be null\");\n\n\t\tOutput.Values = [...Input.Map.values()];\n\t}\n});","/**\n * Apply bitwise AND operator on number (A & B)\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Binary/And\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Binary: And\";\n\t\tiface.w = 95;\n\t}\n\n\tcreateIcon(){\n\t\treturn document.createTextNode('Bin And');\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A & B;\n\t}\n});","/**\n * Apply bitwise OR operator on number (A | B)\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Binary/Or\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Binary: Or\";\n\t\tiface.w = 95;\n\t}\n\n\tcreateIcon(){\n\t\treturn document.createTextNode('Bin Or');\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A | B;\n\t}\n});","/**\n * The left shift operator (<<) shifts the first operand the specified number of bits, modulo 32, to the left.\n * Excess bits shifted off to the left are discarded. Zero bits are shifted in from the right.\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Binary/ShiftLeft\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Binary: ShiftLeft\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-angle-double-left\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A << B;\n\t}\n});","/**\n * Shift bits of a number from left to the right, modulo 32.\n * Excess bits shifted off to the right are discarded.\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Binary/ShiftRight\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Binary: ShiftRight\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-angle-double-right\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A >> B;\n\t}\n});","/**\n * Apply bitwise XOR operator on number (A ^ B)\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Binary/Xor\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Binary: Xor\";\n\t\tiface.w = 95;\n\t}\n\n\tcreateIcon(){\n\t\treturn document.createTextNode('Bin Xor');\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A ^ B;\n\t}\n});","/**\n * Compare and return true if both value is similar\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Compare/Equal\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Number: Equal\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-equals\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A === B;\n\t}\n});","/**\n * Return true if A is less than or equal with B (A <= B)\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Compare/LessThanOrEqual\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Number: Less Than or Equal\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-less-than-equal\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A <= B;\n\t}\n});","/**\n * Return true if A is less than with B (A < B)\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Compare/LessThan\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Number: Less Than\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-less-than\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A < B;\n\t}\n});","/**\n * Return true if A is more than or equal with B (A >= B)\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Compare/MoreThanOrEqual\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Number: More Than or Equal\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-more-than-equal\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A >= B;\n\t}\n});","/**\n * Return true if A is more than with B (A > B)\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Compare/MoreThan\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Number: More Than\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-more-than\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A > B;\n\t}\n});","/**\n * Compare and return true if both value is not similar\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/Compare/NotEqual\",\nclass extends Blackprint.Node {\n\tstatic input = { A: Number, B: Number };\n\tstatic output = { Value: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Number: Not Equal\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-not-equal\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A !== B;\n\t}\n});","/**\n * Return fixed number of a number with specified precision\n * Example: 0.123456 => 0.12 (Precision: 2)\n * @summary Number\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/To/Fixed\",\nclass NumFixed extends Blackprint.Node {\n\tstatic input = { In: Number, Precision: Number };\n\tstatic output = { Out: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"To Fixed\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet { In, Precision } = ref.Input;\n\n\t\tif(In == null) return;\n\t\tref.Output.Out = Number(In.toFixed(Precision));\n\t}\n});","/**\n * Convert number into string type\n * Radix (Optional):\n * 2: Binary string\n * 16: Hex string\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Number/To/String\",\nclass NumString extends Blackprint.Node {\n\tstatic input = { In: Number, Radix: Number };\n\tstatic output = { Out: String };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Number to String\";\n\t\tiface.showPortName = true;\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-magic\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet { In, Radix } = ref.Input;\n\n\t\tif(In == null) return;\n\t\tref.Output.Out = In.toString(Radix);\n\t}\n});","/**\n * Extract object keys or property name as an array\n * @summary Object keys as array\n * @blackprint node\n */\nBlackprint.registerNode('Data/Object/Get/Keys',\nclass extends Blackprint.Node {\n\tstatic input = { Object };\n\tstatic output = { Keys: Array };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Get Object Keys\";\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\t\tOutput.Keys = Object.keys(Input.Object);\n\t}\n});","/**\n * Transverse a object with specified property to get its value inside\n * @summary Dive through object properties\n * @blackprint node\n */\nBlackprint.registerNode('Data/Object/Get/Value',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\t/** Object to be transversed */\n\t\tObject: Object,\n\t\t/** Single narrow field to extract */\n\t\tField: String,\n\t};\n\tstatic output = {\n\t\t/** Extracted value */\n\t\tValue: Blackprint.Types.Any\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Object/Get/Value');\n\t\tiface.title = \"Get Object Value\";\n\n\t\tthis.hasFieldData = false;\n\t\tthis.hasFieldCable = false;\n\t}\n\n\tinit(){\n\t\tlet { IInput, Output } = this.ref;\n\n\t\t// Let's remove data after the cable was disconnected\n\t\tIInput.Object.on('disconnect', Context.EventSlot, () => Output.Value = null);\n\n\t\t// Hide or unhide input box\n\t\tIInput.Field.on('disconnect', Context.EventSlot, () => this.hasFieldCable = false);\n\t\tIInput.Field.on('connect', Context.EventSlot, () => this.hasFieldCable = true);\n\n\t\tif(IInput.Field.default) this.hasFieldData = true;\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\t\tlet { Object: Object_, Field } = Input;\n\n\t\tif(Object_ == null){\n\t\t\tthis.hasFieldData = !!Field;\n\t\t\treturn this.iface._toast.warn(\"Object can't be null or undefined\");\n\t\t}\n\n\t\tif(!!Field){ // not null or empty\n\t\t\tthis.iface._toast.clear();\n\t\t\tthis.hasFieldData = true;\n\t\t\tOutput.Value = Object_[Field];\n\t\t\treturn;\n\t\t}\n\t\telse if(this.hasFieldCable){\n\t\t\tthis.iface._toast.error(\"Field can't be empty string\");\n\t\t\tthis.hasFieldData = false;\n\t\t\treturn;\n\t\t}\n\t\t// else use input box\n\n\t\tthis.hasFieldData = false;\n\n\t\tlet val = null;\n\t\ttry{\n\t\t\tif(this._getter == null) return;\n\t\t\tval = this._getter(Object_);\n\t\t} catch(e) {\n\t\t\tif(e.message.includes === \"Cannot read properties of\"){\n\t\t\t\tOutput.Value = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.iface._toast.error(e.message);\n\t\t}\n\n\t\tOutput.Value = val;\n\t\tthis.iface._toast.clear();\n\t}\n\n\timported(data){ Object.assign(this.iface.data, data) }\n\n\trecreateFunc(props){\n\t\tif(props === '')\n\t\t\treturn this._getter = null;\n\n\t\t// ToDo: support symbol inside of quotes => props[\"my-props\"]\n\t\t// Symbol outside of quotes is forbidden => props.myStuff().hello?.world\n\t\t// Currently this node will support => props.myStuff[\"hello\"].world\n\t\tif(/[`~!@#$%^&*()\\-=+{}|\\\\;:,<>/?]/.test(props))\n\t\t\treturn this.iface._toast.error(\"Can't use symbol when destructuring properties\");\n\n\t\tif(props.slice(0, 1) === '[')\n\t\t\tprops = `_a_${props}`;\n\t\telse props = `_a_.${props}`;\n\n\t\tthis.iface._toast.clear();\n\n\t\ttry{\n\t\t\tthis._getter = Function('_a_', 'return '+props);\n\t\t} catch(e) {\n\t\t\tif(e.message.includes('Unexpected token')){\n\t\t\t\tthis.iface._toast.warn('...?');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.update();\n\t}\n\n\t// Remote sync in\n\tsyncIn(id, data){\n\t\tif(id === 'props') this.iface.props = data;\n\t}\n});\n\nBlackprint.registerInterface('BPIC/Data/Object/Get/Value',\nContext.IFace.GetValue = class extends Blackprint.Interface {\n\tconstructor(node){\n\t\tsuper(node);\n\t\tthis._toast = new NodeToast(this);\n\n\t\tthis.data = new DataObjectGetValueData(this);\n\t}\n});\n\nclass DataObjectGetValueData{\n\t#iface = null;\n\t#props = '';\n\n\tconstructor(iface){\n\t\tthis.#iface = iface;\n\t\tthis.#props = '';\n\t}\n\n\tget props(){ return this.#props }\n\tset props(val){\n\t\tthis.#props = val;\n\t\tlet node = this.#iface.node;\n\n\t\tnode.recreateFunc(val);\n\t\tnode.syncOut('props', val);\n\n\t\t// Let editor know if this iface changed and unsaved\n\t\tnode.notifyEditorDataChanged();\n\t}\n}\n\n// Using getter/setter will make the property not enumerable and Blackprint will skip that property when exporting\nBlackprint.utils.setEnumerablePrototype(DataObjectGetValueData, {\n\tprops: true,\n});","/**\n * Extract object values as an array\n * @summary Object values as array\n * @blackprint node\n */\nBlackprint.registerNode('Data/Object/Get/Values',\nclass extends Blackprint.Node {\n\tstatic input = { Object };\n\tstatic output = { Values: Array };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Get Object Values\";\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref;\n\t\tOutput.Values = Object.values(Input.Object);\n\t}\n});","/**\n * Set value in an object\n * @summary Set value in an object\n * @blackprint node\n */\nBlackprint.registerNode('Data/Object/Set/Value',\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\t/** Object that will be manipulated */\n\t\tObject: Object,\n\t\tField: String,\n\t\tValue: Blackprint.Types.Any,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Set Object Value\";\n\n\t\tthis._toast = new NodeToast(this);\n\t}\n\n\tupdate(){\n\t\tlet { Input } = this.ref;\n\n\t\tif(!Input.Object || !Input.Field)\n\t\t\treturn this._toast.warn(\"Object or Field can't be null or empty\");\n\n\t\tInput.Object[Input.Field] = Input.Value;\n\t}\n});","Blackprint.registerCode('Data/Route/From/Callback',\nclass extends Blackprint.Code {\n\tstatic routeIn = Blackprint.CodeRoute.None;\n\tstatic routeOut = Blackprint.CodeRoute.None;\n\n\t// routes == { traceRoute, routeIn, routeOut }\n\tjs(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tinput: {\n\t\t\t\tValue: `await Output.Route()`\n\t\t\t},\n\t\t\tcode: ``,\n\t\t};\n\t}\n\tpython(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tinput: {\n\t\t\t\tValue: `Output['Route']()`\n\t\t\t},\n\t\t\tcode: ``,\n\t\t};\n\t}\n});","/**\n * Route to other node if the input receive `true` value\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Route/From/Callback\",\nclass extends Blackprint.Node {\n\tstatic input = { Value: Blackprint.Port.Trigger(port => port.iface.ref.Output.Route()) };\n\tstatic output = { Route: Blackprint.Types.Route };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Route on Call\";\n\t}\n\n\tcreateIcon(){\n\t\treturn document.createTextNode('Route ');\n\t}\n});","Blackprint.registerCode('Data/Route/To/Trigger',\nclass extends Blackprint.Code {\n\tstatic routeIn = Blackprint.CodeRoute.MustHave;\n\tstatic routeOut = Blackprint.CodeRoute.Optional;\n\n\t// routes == { traceRoute, routeIn, routeOut }\n\tjs(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tcode: `return await Output.Call();`,\n\t\t};\n\t}\n\tpython(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tcode: `return Output['Call']()`,\n\t\t};\n\t}\n});","/**\n * Trigger function call if data flow's route\n * was reaching to this node\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/Route/To/Trigger\",\nclass extends Blackprint.Node {\n\tstatic output = { Call: Blackprint.Types.Trigger };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"Route to trigger\";\n\t}\n\n\tcreateIcon(){\n\t\treturn document.createTextNode('Call()');\n\t}\n\n\tupdate(){\n\t\tthis.ref.Output.Call();\n\t}\n});","/**\n * Return true if both value is similar\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/Compare/Equal\",\nclass extends Blackprint.Node {\n\tstatic input = { A: String, B: String };\n\tstatic output = { Value: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"String: Equal\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-equals\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet { A, B } = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A === B;\n\t}\n});","/**\n * Return true if both value is not similar\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/Compare/NotEqual\",\nclass extends Blackprint.Node {\n\tstatic input = { A: String, B: String };\n\tstatic output = { Value: Boolean };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"String: Not Equal\";\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-not-equal\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Value = A !== B;\n\t}\n});","/**\n * Fill string with string (padding) on right (end)\n * if the text is less than specified length\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/Padding/End\",\nclass extends Blackprint.Node {\n\tstatic input = { A: String, Length: Number, Filler: String };\n\tstatic output = { Result: String };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Padding End\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, Length, Filler} = ref.Input;\n\n\t\tif(A == null || Length == null) return;\n\t\tref.Output.Result = A.padEnd(Length, Filler);\n\t}\n});","/**\n * Fill string with string (padding) on left (starts)\n * if the text is less than specified length\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/Padding/Start\",\nclass extends Blackprint.Node {\n\tstatic input = { A: String, B: Number };\n\tstatic output = { Result: String };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Padding Start\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet {A, B} = ref.Input;\n\n\t\tif(A == null || B == null) return;\n\t\tref.Output.Result = A.padStart(B);\n\t}\n});","/**\n * Return lowercased letters\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/To/LowerCase\",\nclass LowerCase extends Blackprint.Node {\n\tstatic input = { In: String };\n\tstatic output = { Out: String };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"To LowerCase\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet { In } = ref.Input;\n\n\t\tif(In == null) return;\n\t\tref.Output.Out = In.toUpperCase();\n\t}\n});","/**\n * Convert string to number\n * This may error if the string couldn't be converted to number\n * For example if it's get NaN\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/To/Number\",\nclass Str2Number extends Blackprint.Node {\n\tstatic input = { In: String };\n\tstatic output = { Out: Number };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Data/Minimal');\n\t\tiface.title = \"String to Number\";\n\t\tthis._toast = new NodeToast(iface);\n\t}\n\n\tcreateIcon(){\n\t\treturn $('<i class=\"fa fa-magic\"></i>')[0];\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet { In } = ref.Input;\n\n\t\tif(In == null) return;\n\n\t\t// This does handle exp, oct, hex and binary: 12e1, 0o12, 0x00, 0b00\n\t\tlet temp = Number(In);\n\n\t\tif(Number.isNaN(temp)){\n\t\t\tthis._toast.error(`\"${In}\" is not a number`);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._toast.clear();\n\t\tref.Output.Out = temp;\n\t}\n});","/**\n * Convert string into RegExp\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/To/RegExp\",\nclass Str2RegExp extends Blackprint.Node {\n\tstatic input = { In: String, Options: String };\n\tstatic output = { Out: RegExp };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"To RegExp\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet { In, Options } = ref.Input;\n\n\t\tif(In == null) return;\n\t\tref.Output.Out = RegExp(In, Options);\n\t}\n});","/**\n * Return uppercased letters\n * @summary String\n * @blackprint node\n */\nBlackprint.registerNode(\"Data/String/To/UpperCase\",\nclass UpperCase extends Blackprint.Node {\n\tstatic input = { In: String };\n\tstatic output = { Out: String };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"To UpperCase\";\n\t}\n\n\t// Call update on init, but avoid call if it has route in or input\n\tstatic initUpdate = 0\n\t\t| Blackprint.InitUpdate.NoRouteIn\n\t\t| Blackprint.InitUpdate.NoInputCable;\n\tupdate(){\n\t\tlet ref = this.ref;\n\t\tlet { In } = ref.Input;\n\n\t\tif(In == null) return;\n\t\tref.Output.Out = In.toUpperCase();\n\t}\n});"]}