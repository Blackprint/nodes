{"version":3,"sources":["_init.js","Delay.js","DoN.js","ForLoop.js","Gate.js","Interface.js","Return.code.js","Return.js","Ticker.js","Valve.js","WhileLoop.js","Branch/Route.js","FlipFlop/Route.js","MultiGate/Route.js","Switch/Switch.js","Sequence/Route.js","utils/NodeToast.js"],"names":["_Class","_Class2","_Class3","_Class4","_Class5","_Class6","_Class7","_Class8","_Class9","_Class0","_Class1","_Class10","_Class11","_Class12","window","globalThis","async","imports","urls","sf","loader","mjs","Promise","all","map","v","import","task","Blackprint","loadScope","url","hasInterface","hasDocs","Context","createContext","EventSlot","slot","registerNode","Node","constructor","instance","super","this","setInterface","title","update","r","setTimeout","input","Duration","type","Port","Default","Number","_n","N","output","Counter","Do","End","Reset","Trigger","port","iface","node","Types","Route","_break","_toast","NodeToast","trigger","FirstIndex","LastIndex","Increment","error","i","Index","clear","Start","Break","_toggle","Input","IInput","ref","Toggle","cables","length","Exit","IsOpen","Enter","Boolean","registerInterface","IFace","Interface","registerCode","Code","js","routes","CodeType","NotWrapped","code","csharp","php","python","routeIn","CodeRoute","MustHave","routeOut","None","init","disableOut","Value","Any","start","clearInterval","_inv","setInterval","stop","Stop","data","total","rightPortMargin","portMenu","callback","index","out","createPort","on","ev","active","cable","value","sync","notifyEditorDataChanged","deletePort","name","key","String","renamePort","menu","addMenu","slice","context","push","initPorts","Object","assign","_begin","Condition","True","False","A","B","_disabled","$el","prepend","StartIndex","IsRandom","Loop","Math","random","n","reset","outputs","BPEditor","Dialog","text","indexOf","splice","Case","route","Union","syncOut","normalizePortIndex","syncIn","haveInfo","destroy","haveWarn","haveError","_reduceText","replace","full","info","$decoration","temp","_raw","warn","success"],"mappings":"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","file":"nodes-flowcontrol.mjs","sourcesContent":["// We don't have graphics node for non-browser :3\n// Let's just use this file to load .sf.mjs and .sf.css\n\nlet Blackprint = window.Blackprint.loadScope({\n\t// You can find the URL on Blackprint menu -> Modules\n\t// This will also be exported to JSON if this module's nodes is being used\n\turl: import.meta.url,\n\n\t// This will autoload (*.sf.mjs) and (*.sf.css) file for Browser\n\thasInterface: true,\n\n\t// This will autoload (*.docs.json) for Browser\n\thasDocs: true,\n});\n\n// Global shared context\nlet Context = Blackprint.createContext('FlowControl');\n\n// This is needed to avoid duplicated event listener when using hot reload\n// Event listener that registered with same slot will be replaced\nContext.EventSlot = {slot: 'my-private-event-slot'};","/**\n * This delay node will pause the\n * \"Route In\" for period of time\n * @blackprint node\n */\nBlackprint.registerNode(\"FlowControl/Delay\",\nclass extends Blackprint.Node {\n\tstatic type = \"flow-control\";\n\tstatic input = {\n\t\t/** in miliseconds (1sec = 1000ms) */\n\t\tDuration: Blackprint.Port.Default(Number, 1000),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Delay\";\n\t}\n\n\tasync update(){\n\t\tawait new Promise(r => setTimeout(r, this.input.Duration));\n\t}\n});","/**\n * The DoN node will fire off an execution pulse N times.\n * After the limit has been reached, it will cease all outgoing\n * execution until a pulse is sent into its Reset input.\n * @blackprint node\n */\nBlackprint.registerNode(\"FlowControl/DoN\",\nclass extends Blackprint.Node {\n\tstatic type = \"flow-control\";\n\tstatic input = {\n\t\t/** This input sets the number of times the DoN node will trigger */\n\t\tN: Blackprint.Port.Default(Number, 1),\n\t\t/** This execution input will reset the DoN node so that it can be triggered again. */\n\t\tReset: Blackprint.Port.Trigger(port => port.iface.node._n = 0),\n\t};\n\tstatic output = {\n\t\t/**\n\t\t * This port will only triggered if the DoN\n\t\t * has not yet been triggered more than N times,\n\t\t * or if its Reset input has been called.\n\t\t */\n\t\tDo: Blackprint.Types.Route,\n\t\t/**\n\t\t * This port will triggered once if DoN\n\t\t * Already triggered for N times.\n\t\t */\n\t\tEnd: Blackprint.Types.Route,\n\t\tCounter: Number,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Do N\";\n\t\tthis._n = 0;\n\t}\n\n\tupdate(){\n\t\tif(this._n >= this.input.N) return;\n\t\tthis._n++;\n\n\t\tlet output = this.output;\n\t\toutput.Counter = this._n;\n\t\toutput.Do();\n\n\t\tif(this._n === this.input.N) output.End();\n\t}\n});","/**\n * The ForLoop node works like a standard code loop,\n * firing off an execution pulse for each index between a start and end.\n * @blackprint node\n */\nBlackprint.registerNode(\"FlowControl/ForLoop\",\nclass extends Blackprint.Node {\n\tstatic type = \"flow-control\";\n\tstatic input = {\n\t\t/** Reset the index and begin the loop */\n\t\tStart: Blackprint.Port.Trigger(port => port.iface.node.trigger()),\n\t\t/** Takes in an Int representing the first index of the loop */\n\t\tFirstIndex: Blackprint.Port.Default(Number, 0),\n\t\t/** Takes in an Int representing the last index of the loop */\n\t\tLastIndex: Blackprint.Port.Default(Number, 10),\n\t\t/** Put negative value if your want to use decremental loop */\n\t\tIncrement: Blackprint.Port.Default(Number, 1),\n\t\t/** Break the loop and reset the index */\n\t\tBreak: Blackprint.Port.Trigger(port => port.iface.node._break = true),\n\t};\n\tstatic output = {\n\t\t/** This will be called every index increment */\n\t\tDo: Blackprint.Types.Route,\n\t\t/** Current loop's index */\n\t\tIndex: Number,\n\t\t/**\n\t\t * This will be called after the loop ended,\n\t\t * including break\n\t\t */\n\t\tEnd: Blackprint.Types.Route,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"For Loop\";\n\n\t\tthis._break = false;\n\t\tthis._toast = new NodeToast(iface);\n\t}\n\n\tasync trigger(){\n\t\tlet { FirstIndex, LastIndex, Increment } = this.input;\n\t\tlet output = this.output;\n\n\t\tif(FirstIndex < LastIndex){\n\t\t\tif(Increment <= 0)\n\t\t\t\treturn this._toast.error(\"Increment value may cause infinity loop\");\n\n\t\t\tfor (let i=FirstIndex; i < LastIndex; i += Increment) {\n\t\t\t\tif(this._break) break;\n\n\t\t\t\toutput.Index = i;\n\t\t\t\tawait output.Do();\n\t\t\t}\n\t\t}\n\t\telse if(FirstIndex > LastIndex){\n\t\t\tif(Increment >= 0)\n\t\t\t\treturn this._toast.error(\"Increment value may cause infinity loop\");\n\n\t\t\tfor (let i=FirstIndex; i > LastIndex; i += Increment) {\n\t\t\t\tif(this._break) break;\n\n\t\t\t\toutput.Index = i;\n\t\t\t\tawait output.Do();\n\t\t\t}\n\t\t}\n\n\t\tthis._toast.clear();\n\t\tthis._break = false;\n\t\toutput.End();\n\t}\n});","/**\n * A Gate node is used as a way to open and close a stream of execution.\n * If the gate is open, then Enter port will trigger Exit function\n * If the gate is closed, then Enter port will will not trigger the Exit\n * @blackprint node\n */\nBlackprint.registerNode(\"FlowControl/Gate\",\nclass extends Blackprint.Node {\n\tstatic type = \"flow-control\";\n\tstatic input = {\n\t\t/** Trigger the Exit function */\n\t\tEnter: Blackprint.Port.Trigger(port => port.iface.node.trigger()),\n\t\t/** Default to closed */\n\t\tIsOpen: Blackprint.Port.Default(Boolean, false),\n\t\t/** If you use this, IsOpen port mustn't be connected to any cable */\n\t\tToggle: Blackprint.Port.Trigger(port => {\n\t\t\tlet node = port.iface.node;\n\t\t\tif(node._toggle == null) node._toggle = node.input.IsOpen;\n\n\t\t\tnode._toggle = !node._toggle;\n\t\t}),\n\t};\n\tstatic output = {\n\t\t/** You can use \"Route Out\" port in case you need to route node */\n\t\tExit: Blackprint.Types.Trigger,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Gate\";\n\t\tthis._toggle = null;\n\t}\n\n\ttrigger(){\n\t\tlet { Input, IInput } = this.ref;\n\n\t\tif(IInput.Toggle.cables.length){\n\t\t\tif(this._toggle) this.output.Exit();\n\t\t\treturn;\n\t\t}\n\n\t\tif(Input.IsOpen) this.output.Exit();\n\t}\n});","Blackprint.registerInterface('BPIC/FlowControl/Interface',\nContext.IFace.Interface = class extends Blackprint.Interface { });","Blackprint.registerCode('FlowControl/Return',\nclass extends Blackprint.Code {\n\tstatic routeIn = Blackprint.CodeRoute.MustHave;\n\tstatic routeOut = Blackprint.CodeRoute.None;\n\n\t// routes == { traceRoute, routeIn, routeOut }\n\tjs(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tcode: `return Input.Value;`,\n\t\t};\n\t}\n\n\tcsharp(routes){ return this.php(routes); }\n\tphp(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tcode: `return Input[\"Value\"];`,\n\t\t};\n\t}\n\n\tpython(routes){\n\t\treturn {\n\t\t\ttype: Blackprint.CodeType.NotWrapped,\n\t\t\tcode: `return Input[\"Value\"]`,\n\t\t};\n\t}\n});","/**\n * This is used for code generation to return value for the function call.\n * This node will do nothing if being used for Blackprint Engine/Sketch.\n * @summary For code generation only\n * @blackprint node\n */\nBlackprint.registerNode(\"FlowControl/Return\",\nclass extends Blackprint.Node {\n\tstatic type = \"flow-control\";\n\tstatic input = { Value: Blackprint.Types.Any };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Return\";\n\t}\n\n\tinit(){\n\t\t// Disable route out\n\t\tthis.routes.disableOut = true;\n\t}\n\n\t// No operation\n\tupdate(){}\n});","/**\n * This ticker node will trigger\n * \"Route Out\" every period of time (interval)\n * @blackprint node\n */\nBlackprint.registerNode(\"FlowControl/Ticker\",\nclass extends Blackprint.Node {\n\tstatic type = \"flow-control\";\n\tstatic input = {\n\t\t/** in miliseconds (1sec = 1000ms) */\n\t\tDuration: Blackprint.Port.Default(Number, 1000),\n\t\tStart: Blackprint.Port.Trigger(port => port.iface.node.start()),\n\t\tStop: Blackprint.Port.Trigger(port => port.iface.node.stop()),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Ticker\";\n\t}\n\n\tstart(){\n\t\tclearInterval(this._inv);\n\t\tthis._inv = setInterval(() => this.routes.routeOut(), this.input.Duration);\n\t}\n\n\tstop(){\n\t\tclearInterval(this._inv);\n\t}\n});","/**\n * Pass input value to output when the condition was true\n * Output will automatically resync even value is not changed\n * @blackprint node\n */\nBlackprint.registerNode(\"FlowControl/Valve\",\nclass extends Blackprint.Node {\n\tstatic type = \"flow-control\";\n\tstatic input = {\n\t\t/** Value to be streamed through valve */\n\t\tValue: Blackprint.Types.Any,\n\t\t/** Default value is valve was closed/false */\n\t\tDefault: Blackprint.Types.Any,\n\t};\n\tstatic output = { };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/FlowControl/Interface');\n\t\tiface.title = \"Valve\";\n\t\tiface.data = {total: 1};\n\t\tiface.rightPortMargin = '38px 0 0 0';\n\t}\n\n\tinit(){\n\t\tlet node = this;\n\t\tlet iface = this.iface;\n\n\t\t// Put this array here, and reuse when port menu event\n\t\tvar portMenu = [{\n\t\t\ttitle: \"Create new port\", callback(){\n\t\t\t\tlet index = iface.data.total++;\n\t\t\t\tlet out = node.createPort('output', index, Blackprint.Types.Any);\n\t\t\t\tlet inp = node.createPort('input', index, Boolean);\n\n\t\t\t\tinp.on('value', (ev) => {\n\t\t\t\t\tlet active = ev.cable.value;\n\t\t\t\t\tlet input = node.input;\n\n\t\t\t\t\tout.value = active ? input.Value : input.Default;\n\t\t\t\t\tout.sync();\n\t\t\t\t});\n\n\t\t\t\t// Let editor know if this iface changed and unsaved\n\t\t\t\tnode.notifyEditorDataChanged();\n\t\t\t}\n\t\t}, {\n\t\t\ttitle: \"Delete this port\", callback(){\n\t\t\t\tnode.deletePort('output', this.name);\n\t\t\t\tnode.deletePort('input', this.name);\n\t\t\t\tiface.data.total--;\n\n\t\t\t\t// Normalize ports index\n\t\t\t\tlet i = 0;\n\t\t\t\tlet input = iface.input;\n\t\t\t\tfor (let key in input) {\n\t\t\t\t\tlet port = input[key];\n\t\t\t\t\tif(port.name === 'Value' || port.name === 'Default') continue;\n\n\t\t\t\t\tif(port.name !== String(i))\n\t\t\t\t\t\tnode.renamePort('input', port.name, String(i));\n\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\ti = 0;\n\t\t\t\tlet output = iface.output;\n\t\t\t\tfor (let key in output) {\n\t\t\t\t\tlet port = output[key];\n\n\t\t\t\t\tif(port.name !== String(i))\n\t\t\t\t\t\tnode.renamePort('output', port.name, String(i));\n\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\t// Let editor know if this iface changed and unsaved\n\t\t\t\tnode.notifyEditorDataChanged();\n\t\t\t}\n\t\t}];\n\n\t\tiface.on('port.menu', Context.EventSlot, function({ port, menu }){\n\t\t\tlet addMenu;\n\t\t\tif(port.name === 'Value' || port.name === 'Default')\n\t\t\t\taddMenu = [portMenu[0]];\n\t\t\telse addMenu = portMenu.slice(0);\n\n\t\t\tfor (var i = 0; i < addMenu.length; i++) {\n\t\t\t\t// Change every callback context to refer current port\n\t\t\t\taddMenu[i].context = port;\n\t\t\t}\n\n\t\t\tmenu.push(...addMenu);\n\t\t});\n\t}\n\n\tinitPorts(data){\n\t\tdata = Object.assign(this.iface.data, data);\n\n\t\tfor (let i=0; i < data.total; i++) {\n\t\t\tlet out = this.createPort('output', String(i), Blackprint.Types.Any);\n\t\t\tlet inp = this.createPort('input', String(i), Boolean);\n\n\t\t\tinp.on('value', (ev) => {\n\t\t\t\tlet active = ev.cable.value;\n\t\t\t\tlet input = this.input;\n\n\t\t\t\tout.value = active ? input.Value : input.Default;\n\t\t\t\tout.sync();\n\t\t\t});\n\t\t}\n\t}\n});","/**\n * If the condition remains true, it keeps executing the Do loop.\n * If the test condition returns false, the Engine terminates the\n * loop and exits the loop's body.\n * @blackprint node\n */\nBlackprint.registerNode(\"FlowControl/WhileLoop\",\nclass extends Blackprint.Node {\n\tstatic type = \"flow-control\";\n\tstatic input = {\n\t\t/** Start the while loop */\n\t\tStart: Blackprint.Port.Trigger(port => port.iface.node.trigger()),\n\t\t/** This is the loop's test condition */\n\t\tCondition: Boolean,\n\t};\n\tstatic output = {\n\t\t/** This port will triggered every time the condition still true */\n\t\tDo: Blackprint.Types.Route,\n\t\t/** This port will triggered once the loop was ended */\n\t\tEnd: Blackprint.Types.Route,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"WhileLoop\";\n\t}\n\n\tasync trigger(){\n\t\tif(this._begin) return; // Avoid multiple trigger\n\t\tthis._begin = true;\n\n\t\twhile(this.input.Condition)\n\t\t\tawait output.Do();\n\n\t\tthis._begin = false;\n\t\toutput.End();\n\t}\n});","/**\n * Trigger route based on boolean's condition\n * @blackprint node\n */\nBlackprint.registerNode(\"FlowControl/Branch/Route\",\nclass extends Blackprint.Node {\n\tstatic type = \"flow-control\";\n\tstatic input = {\n\t\tCondition: Boolean,\n\t};\n\tstatic output = {\n\t\tTrue: Blackprint.Types.Route,\n\t\tFalse: Blackprint.Types.Route,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Branch\";\n\t}\n\n\tupdate(){\n\t\tlet Condition = this.input.Condition;\n\t\tif(Condition == null) return;\n\n\t\tif(Condition) this.output.True();\n\t\telse this.output.False();\n\t}\n});","/**\n * The FlipFlop node takes in an execution output and\n * toggles between two execution outputs. The first time it is called,\n * output A executes. The second time, B. Then A, then B, and so on.\n * @blackprint node\n */\nBlackprint.registerNode(\"FlowControl/FlipFlop/Route\",\nclass extends Blackprint.Node {\n\tstatic type = \"flow-control\";\n\tstatic output = {\n\t\tA: Blackprint.Types.Route,\n\t\tB: Blackprint.Types.Route,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"FlipFlop\";\n\t\tthis._n = 0;\n\t}\n\n\tupdate(){\n\t\tlet n = this._n;\n\t\tif(n === 0){\n\t\t\tthis._n = 1;\n\t\t\toutput.A();\n\t\t}\n\t\telse{\n\t\t\tthis._n = 0;\n\t\t\toutput.B();\n\t\t}\n\t}\n});","/**\n * Trigger a series of route in order\n * @blackprint node\n */\nBlackprint.registerNode(\"FlowControl/MultiGate/Route\",\nclass extends Blackprint.Node {\n\tstatic type = \"flow-control\";\n\tstatic input = {\n\t\t/** Reset the order and allow recall */\n\t\tReset: Blackprint.Port.Trigger(port => port.iface.node.reset()),\n\t\t/** Choose outputs in random order */\n\t\tIsRandom: Blackprint.Port.Default(Boolean, false),\n\t\t/**\n\t\t * True: will reset the order and allow recall\n\t\t * False: will diallow port that already called\n\t\t */\n\t\tLoop: Blackprint.Port.Default(Boolean, true),\n\t\tStartIndex: Blackprint.Port.Default(Number, 0),\n\t};\n\tstatic output = {\n\t\t'0': Blackprint.Types.Route,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"MultiGate\";\n\t\tiface.data = {total: 1};\n\n\t\tthis._disabled = false;\n\t}\n\n\tinit(){\n\t\tlet node = this;\n\t\tlet iface = this.iface;\n\n\t\t// Put this array here, and reuse when port menu event\n\t\tvar portMenu = [{\n\t\t\ttitle: \"Create new port\", callback(){\n\t\t\t\tlet index = iface.data.total++;\n\t\t\t\tnode.createPort('output', index, Blackprint.Types.Route);\n\n\t\t\t\t// Let editor know if this iface changed and unsaved\n\t\t\t\tnode.notifyEditorDataChanged();\n\t\t\t}\n\t\t}, {\n\t\t\ttitle: \"Delete this port\", callback(){\n\t\t\t\tnode.deletePort('output', this.name);\n\t\t\t\tiface.data.total--;\n\n\t\t\t\t// Normalize ports index\n\t\t\t\tlet i = 0;\n\t\t\t\tlet input = iface.input;\n\t\t\t\tfor (let key in input) {\n\t\t\t\t\tlet port = input[key];\n\t\t\t\t\tif(port.name !== String(i))\n\t\t\t\t\t\tnode.renamePort('input', port.name, String(i));\n\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\t// Let editor know if this iface changed and unsaved\n\t\t\t\tnode.notifyEditorDataChanged();\n\t\t\t}\n\t\t}];\n\n\t\tiface.on('port.menu', Context.EventSlot, function({ port, menu }){\n\t\t\tlet addMenu;\n\t\t\tif(port.name === '0')\n\t\t\t\taddMenu = [portMenu[0]];\n\t\t\telse addMenu = portMenu.slice(0);\n\n\t\t\tfor (var i = 0; i < addMenu.length; i++) {\n\t\t\t\t// Change every callback context to refer current port\n\t\t\t\taddMenu[i].context = port;\n\t\t\t}\n\n\t\t\tmenu.push(...addMenu);\n\t\t});\n\n\t\tif(iface.$el){\n\t\t\tiface.$el('.title .icon').prepend('<i class=\"fa fa-sign-in-alt\"></i>');\n\t\t}\n\t}\n\n\tinitPorts(data){\n\t\tdata = Object.assign(this.iface.data, data);\n\n\t\tfor (let i=0; i < data.total; i++) {\n\t\t\tthis.createPort('output', String(i), Blackprint.Types.Route);\n\t\t}\n\t}\n\n\tasync update(){\n\t\tif(this._disabled) return;\n\n\t\tlet input = this.input;\n\t\tlet output = this.output;\n\t\tlet total = this.iface.data.total;\n\t\tthis._n ??= input.StartIndex;\n\n\t\tif(input.IsRandom){\n\t\t\tif(!input.Loop){\n\t\t\t\t// ToDo: mark port that have been called and avoid recall\n\t\t\t\t// Only allow recall after reset or loop is enabled\n\t\t\t\tthrow \"ToDo\";\n\t\t\t}\n\n\t\t\tawait output[Math.random() * total | 0]();\n\t\t\treturn;\n\t\t}\n\n\t\tlet n = this._n++;\n\t\tif(this._n >= total) {\n\t\t\tif(!input.Loop) this._n = input.StartIndex;\n\t\t\telse this._disabled = true;\n\t\t}\n\n\t\tawait output[n]();\n\t}\n\n\treset(){\n\t\tthis._disabled = false;\n\t\tthis._n = this.input.StartIndex;\n\t}\n});","/**\n * Switch route flow based on input value\n * @blackprint node\n */\nBlackprint.registerNode(\"FlowControl/Switch/Route\",\nclass extends Blackprint.Node {\n\tstatic type = \"flow-control\";\n\tstatic input = {\n\t\t/** Value for activating output route */\n\t\tCase: Blackprint.Port.Union([String, Number]),\n\t};\n\tstatic output = {\n\t\t/** Default route is cases doesn't match */\n\t\t\"​Defa​ult\": Blackprint.Types.Route, // The first and fiveth char is a zero width character\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Switch\";\n\t\tiface.data = {outputs: []};\n\t}\n\n\tinit(){\n\t\tlet node = this;\n\t\tlet iface = this.iface;\n\n\t\t// Put this array here, and reuse when port menu event\n\t\tvar portMenu = [{\n\t\t\ttitle: \"Create new port\", async callback(){\n\t\t\t\tlet name = await BPEditor.Dialog({\n\t\t\t\t\ttitle: \"Port name:\",\n\t\t\t\t\ttext: \"This port will active when 'Case' does match with this port name\",\n\t\t\t\t\tinput: \"text\",\n\t\t\t\t});\n\n\t\t\t\tname = name.value;\n\t\t\t\tif(!name) return;\n\n\t\t\t\tnode.createPort('output', name, Blackprint.Types.Route);\n\t\t\t\tiface.data.outputs.push(name);\n\n\t\t\t\t// Let editor know if this iface changed and unsaved\n\t\t\t\tnode.notifyEditorDataChanged();\n\t\t\t}\n\t\t}, {\n\t\t\ttitle: \"Delete this port\", callback(){\n\t\t\t\tlet outputs = iface.data.outputs;\n\t\t\t\tlet i = outputs.indexOf(this.name);\n\n\t\t\t\tif(i === -1) return;\n\t\t\t\toutputs.splice(i, 1);\n\t\t\t\tnode.deletePort('output', this.name);\n\n\t\t\t\t// Let editor know if this iface changed and unsaved\n\t\t\t\tnode.notifyEditorDataChanged();\n\t\t\t}\n\t\t}];\n\n\t\tiface.on('port.menu', Context.EventSlot, function({ port, menu }){\n\t\t\tlet addMenu;\n\t\t\tif(port.name === 'Case')\n\t\t\t\taddMenu = [portMenu[0]];\n\t\t\telse addMenu = portMenu.slice(0);\n\n\t\t\tfor (var i = 0; i < addMenu.length; i++) {\n\t\t\t\t// Change every callback context to refer current port\n\t\t\t\taddMenu[i].context = port;\n\t\t\t}\n\n\t\t\tmenu.push(...addMenu);\n\t\t});\n\n\t\tif(iface.$el){\n\t\t\tiface.$el('.title .icon').prepend('<i class=\"fa fa-random\"></i>');\n\t\t}\n\t}\n\n\tinitPorts(data){\n\t\tdata = Object.assign(this.iface.data, data);\n\t\tlet outputs = data.outputs;\n\n\t\tfor (let i=0; i < outputs.length; i++) {\n\t\t\tthis.createPort('output', outputs[i], Blackprint.Types.Route);\n\t\t}\n\t}\n\n\tupdate(){\n\t\tlet Case = String(this.input.Case);\n\t\tif(!Case) return;\n\n\t\tlet route = this.output[Case];\n\t\tif(route) route();\n\t\telse this.output[\"​Defa​ult\"]();\n\t}\n});","/**\n * Trigger a series of route in order\n * @blackprint node\n */\nBlackprint.registerNode(\"FlowControl/Sequence/Route\",\nclass extends Blackprint.Node {\n\tstatic type = \"flow-control\";\n\tstatic output = {\n\t\t'0': Blackprint.Types.Route,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Sequence\";\n\t\tiface.data = {total: 1};\n\t}\n\n\tinit(){\n\t\tlet node = this;\n\t\tlet iface = this.iface;\n\n\t\t// Put this array here, and reuse when port menu event\n\t\tvar portMenu = [{\n\t\t\ttitle: \"Create new port\", callback(){\n\t\t\t\tlet index = iface.data.total++;\n\t\t\t\tnode.createPort('output', index, Blackprint.Types.Route);\n\t\t\t\tnode.syncOut('addPort', ''+iface.data.total);\n\n\t\t\t\t// Let editor know if this iface changed and unsaved\n\t\t\t\tnode.notifyEditorDataChanged();\n\t\t\t}\n\t\t}, {\n\t\t\ttitle: \"Delete this port\", callback(){\n\t\t\t\tnode.deletePort('output', this.name);\n\t\t\t\tiface.data.total--;\n\t\t\t\tnode.normalizePortIndex();\n\t\t\t\tnode.syncOut('deletePort', this.name);\n\n\t\t\t\t// Let editor know if this iface changed and unsaved\n\t\t\t\tnode.notifyEditorDataChanged();\n\t\t\t}\n\t\t}];\n\n\t\tiface.on('port.menu', Context.EventSlot, function({ port, menu }){\n\t\t\tlet addMenu;\n\t\t\tif(port.name === '0')\n\t\t\t\taddMenu = [portMenu[0]];\n\t\t\telse addMenu = portMenu.slice(0);\n\n\t\t\tfor (var i = 0; i < addMenu.length; i++) {\n\t\t\t\t// Change every callback context to refer current port\n\t\t\t\taddMenu[i].context = port;\n\t\t\t}\n\n\t\t\tmenu.push(...addMenu);\n\t\t});\n\n\t\tif(iface.$el){\n\t\t\tiface.$el('.title .icon').prepend('<i class=\"fa fa-sign-in-alt\"></i>');\n\t\t}\n\t}\n\n\tinitPorts(data){\n\t\tdata = Object.assign(this.iface.data, data);\n\n\t\tfor (let i=0; i < data.total; i++) {\n\t\t\tthis.createPort('output', String(i), Blackprint.Types.Route);\n\t\t}\n\t}\n\n\tasync update(){\n\t\tif(this._begin) return; // Avoid multiple trigger\n\t\tthis._begin = true;\n\n\t\tlet output = this.output;\n\t\tfor (let key in output)\n\t\t\tawait output[key]();\n\n\t\tthis._begin = false;\n\t}\n\n\tnormalizePortIndex(){\n\t\t// Normalize ports index\n\t\tlet i = 0;\n\t\tlet output = this.iface.output;\n\t\tfor (let key in output) {\n\t\t\tlet port = output[key];\n\t\t\tif(port.name !== String(i))\n\t\t\t\tthis.renamePort('output', port.name, String(i));\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\tasync syncIn(name, value){\n\t\tlet iface = this.iface;\n\t\tif(name === 'deletePort') {\n\t\t\tthis.deletePort('output', String(value));\n\t\t\tthis.normalizePortIndex();\n\t\t\tiface.data.total--;\n\t\t}\n\t\telse if(name === 'addPort') {\n\t\t\tlet total = iface.data.total;\n\t\t\tif(total < value) {\n\t\t\t\tfor (let i = total; i < value; i++) {\n\t\t\t\t\tthis.createPort('output', String(i), Blackprint.Types.Route);\n\t\t\t\t\tiface.data.total++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});","// Bootstrap for add toast on node decoration\nlet NodeToast = Context.NodeToast = class NodeToast { // eslint-disable-line\n\tconstructor(iface){\n\t\tthis.iface = iface;\n\t}\n\n\tclear(){\n\t\tif(this.haveInfo)\n\t\t\tthis.haveInfo.destroy();\n\t\tif(this.haveWarn)\n\t\t\tthis.haveWarn.destroy();\n\t\tif(this.haveError)\n\t\t\tthis.haveError.destroy();\n\n\t\tthis.haveInfo = false;\n\t\tthis.haveWarn = false;\n\t\tthis.haveError = false;\n\t}\n\n\t_reduceText(text){\n\t\treturn text.replace(/\\w{15,}/g, full => full.slice(0, 5)+'...');\n\t}\n\n\tinfo(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveInfo)\n\t\t\tthis.haveInfo.text = text;\n\t\telse\n\t\t\tthis.haveInfo = this.iface.$decoration.info(text);\n\n\t\tthis.haveInfo._raw = temp;\n\t}\n\n\twarn(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveWarn)\n\t\t\tthis.haveWarn.text = text;\n\t\telse\n\t\t\tthis.haveWarn = this.iface.$decoration.warn(text);\n\n\t\tthis.haveWarn._raw = temp;\n\t}\n\n\terror(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveError)\n\t\t\tthis.haveError.text = text;\n\t\telse\n\t\t\tthis.haveError = this.iface.$decoration.error(text);\n\n\t\tthis.haveError._raw = temp;\n\t}\n\n\tsuccess(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet ref = this.iface.$decoration.success(this._reduceText(text));\n\t\tref._raw = text;\n\t}\n}"]}